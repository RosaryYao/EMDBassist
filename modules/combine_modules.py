"""
.tbl field values (1-based index)
https://wiki.dynamo.biozentrum.unibas.ch/w/index.php/Table_convention

1  : tag tag of particle file in data folder
2  : aligned value 1: marks the particle for alignment
3  : averaged value 1: the particle was included in the average
4  : dx x shift from center (in pixels)
5  : dy y shift from center (in pixels)
6  : dz z shift from center (in pixels)
7  : tdrot euler angle (rotation around z, in degrees)
8  : tilt euler angle (rotation around new x, in degrees)
9  : narot euler angle (rotation around new z, in degrees)
10  : cc Cross correlation coefficient
11  : cc2 Cross correlation coefficient after thresholding II
12  : cpu processor that aligned the particle
13  : ftype 0: full range; 1: tilt around y ( ... dhelp dtutorial for more options)
14  : ymintilt minimum angle in the tilt series around tilt axis (i.e. -60)
15  : ymaxtilt maximum angle in the tilt series around tilt axis (i.e. 60)
16  : xmintilt minimum angle in the tilt series around second tilt axis (i.e. -60)
17  : xmaxtilt maximum angle in the tilt series around second x (i.e. 60)
18  : fs1 free parameter for fourier sampling #1()
19  : fs2 free parameter for fourier sampling #2()
20  : tomo tomogram number
21  : reg for arbitrary assignations of regions inside tomograms
22  : class class number
23  : annotation use this field for assigning arbitrary labels
24  : x x coordinate in original volume
25  : y y coordinate in original volume
26  : z z coordinate in original volume
27  : dshift norm of shift vector
28  : daxis difference in axis orientation
29  : dnarot difference in narot
30  : dcc difference in CC
31  : otag original tag (subboxing)
32  : npar number of added particles (compactions) / subunit label (subboxing)
34  : ref reference. Used in multireference projects
35  : sref subreference (i.e. generated by Dynamo PCA)
36  : apix angstrom per pixel
37  : def defocus (in micron)
41  : eig1 "eigencoefficient" #1
42  : eig2 "eigencoefficient" #2
"""
import zlib

"""
Brigg's lab .motl field values
1)     Cross-correlation coefficient
2)     Not used
3)     Not used
4)     Subtomogram number (each subtomogram is named “subtomo_number”).
5)     Tomogram number
6)     Virus number
7)     Tomogram number (this row is redundant for historical reasons)
8)     x coordinate within the tomogram
9)     y coordinate within the tomogram
10)   z coordinate within the tomogram
11)   x shift of the subtomogram
12)   y shift of the subtomogram
13)   z shift of the subtomogram
14)   not used
15)   not used
16)   not used
17)   Phi angle in degrees (third rotation, it is an in plane rotation)
18)   Psi angle in degrees (first rotation, it is an in plane rotation)
19)   Theta angle in degrees (second rotation, it is an out of plane rotation)
20)   Class number (not relevant for our purpose)
"""

import argparse
import base64
import math
import os
import struct
import sys

import mrcfile
import numpy as np


# Define rotation matrices (anticlockwise)
def matrix_z(theta):
    matrix = np.array([
        [math.cos(theta), -math.sin(theta), 0],
        [math.sin(theta), math.cos(theta), 0],
        [0, 0, 1]
    ])
    return matrix


def matrix_y(theta):
    matrix = np.array([
        [math.cos(theta), 0, math.sin(theta)],
        [0, 1, 0],
        [-math.sin(theta), 0, math.cos(theta)]
    ])
    return matrix


def matrix_x(theta):
    matrix = np.array([
        [1, 0, 0],
        [0, math.cos(theta), -math.sin(theta)],
        [0, math.sin(theta), math.cos(theta)]
    ])
    return matrix


def rotate(a, b, c, convention="zxz"):
    """
    Rotation uses Euler angles. 6 conventions exist: "zxz", "zyz", "xzx", "xyx", "yxy", "yzy". Default is "zxz" convention.
    Rotation here is anticlockwise, since Dynamo rotates objects in clockwise direction.
    """

    if convention == "zxz":
        return matrix_z(a).dot(matrix_x(b)).dot(matrix_z(c))
    elif convention == "zyz":
        return matrix_z(a).dot(matrix_y(b)).dot(matrix_z(c))
    elif convention == "yzy":
        return matrix_y(a).dot(matrix_z(b)).dot(matrix_y(c))
    elif convention == "yxy":
        return matrix_y(a).dot(matrix_x(b)).dot(matrix_y(c))
    elif convention == "xzx":
        return matrix_x(a).dot(matrix_z(b)).dot(matrix_x(c))
    elif convention == "xyx":
        return matrix_x(a).dot(matrix_y(b)).dot(matrix_x(c))
    else:
        raise NameError("convention not supported!")


class Map:
    def __init__(self, fn):
        self.fn = fn
        self.mode, self.cols, self.rows, self.sections, self.data, self.origin, self.voxel_size = self._get_data(fn)

    def _get_data(self, fn):
        with mrcfile.open(fn) as mrc:
            mode = mrc.header.mode
            cols = mrc.header.nx
            rows = mrc.header.ny
            sections = mrc.header.nz
            origin = mrc.header.nxstart, mrc.header.nystart, mrc.header.nzstart
            voxel_size = mrc.voxel_size  # Would be a tuple?
            data = mrc.data
        return mode, cols, rows, sections, data, origin, voxel_size


class File:
    def __init__(self, fn):
        self.fn = fn
        self.cols, self.rows, self.col_data = self._get_data(fn)
        # Define a list of tbl_row

    def _get_data(self, fn):
        raise NotImplementedError

    def __getitem__(self, index):
        return self.col_data[index]


class Motl(File):
    def _get_data(self, fn):
        with open(fn, "r") as f:
            row_data = f.readlines()
            col_data = [row.strip().split(",") for row in row_data]
            try:
                length_row = [len(row) for row in col_data]
                assert sum(length_row) / len(length_row) == length_row[0]
            except AssertionError:
                raise ValueError("Number of columns are not equal on all rows!")
        return len(col_data[0]), len(row_data), col_data


class Tbl(File):
    def _get_data(self, fn):
        with open(fn, "r") as f:
            row_data = f.readlines()
            col_data = [row.strip().split(" ") for row in row_data]
            try:
                length_row = [len(row) for row in col_data]
                assert sum(length_row) / len(length_row) == length_row[0]
            except AssertionError:
                raise ValueError("Number of columns are not equal on all rows!")
        return len(col_data[0]), len(row_data), col_data


class MotlRow:
    def __init__(self, motl_row, voxel_size=(1.0, 1.0, 1.0)):
        self.row = motl_row
        self.size = voxel_size
        # change each element in the tbl_row into float
        self.dx, self.dy, self.dz, self.tdrot, self.tilt, self.narot, \
        self.x, self.y, self.z = self._get_data(motl_row)
        self.transformation = self._transform()

    def _get_data(self, tbl_row):
        dx, dy, dz = float(self.row[10]), float(self.row[11]), float(self.row[12])  # todo: fix here
        if dx != 0 or dy != 0 or dz != 0:
            raise ValueError("shifts in x, y, z are note equal to zero")

        tdrot, tilt, narot = float(self.row[17]), float(self.row[18]), float(self.row[16])
        x, y, z = float(self.row[7]), float(self.row[8]), float(self.row[9])
        return dx, dy, dz, tdrot, tilt, narot, x, y, z

    def _transform(self):
        rotation = rotate(math.radians(self.tdrot), math.radians(self.tilt), math.radians(self.narot))
        # Since dx, dy and dz are zeros, try
        #translation = np.array(
        #    [self.y * self.size[1],
        #     self.x * self.size[0],
        #     self.z * self.size[2]])

        # todo: have to modify self.size
        # self.size = [1.78/4, 1.78/4, 1.78/4]
        translation = np.array(
          [self.x * self.size[0],
           self.y * self.size[1],
           self.z * self.size[2]])

        #translation = np.array(
        #    [self.x,
        #     self.y,
        #     self.z]
        #)

        # translation = np.array([
        #    self.x * 0.445,  # so now divided by 1.78/4
        #    self.y * 0.445,
        #    self.z * 0.445
        # ])

        transformation = np.insert(rotation, 3, translation, axis=1)
        return transformation

    def __str__(self):
        return f"Tbl_row={self.row}, voxel_size={self.size}"


class TblRow:
    def __init__(self, tbl_row, voxel_size=(1.0, 1.0, 1.0)):
        self.row = tbl_row
        self.size = voxel_size
        # change each element in the tbl_row into float
        self.dx, self.dy, self.dz, self.tdrot, self.tilt, self.narot, \
        self.x, self.y, self.z, self.dshift, self.daxis, self.dnarot = self._get_data(tbl_row)
        self.transformation = self._transform()

    def _get_data(self, tbl_row):
        dx, dy, dz = float(self.row[3]), float(self.row[4]), float(self.row[5])
        tdrot, tilt, narot = float(self.row[6]), float(self.row[7]), float(self.row[8])
        x, y, z = float(self.row[23]), float(self.row[24]), float(self.row[25])
        dshift, daxis, dnarot = float(self.row[26]), float(self.row[27]), float(self.row[28])
        return dx, dy, dz, tdrot, tilt, narot, x, y, z, dshift, daxis, dnarot

    # todo: Caution! Additional *self.size[i]. WHY???
    def _transform(self):
        rotation = rotate(math.radians(self.tdrot), math.radians(self.tilt), math.radians(self.narot))
        transformation = np.insert(rotation, 3, [(self.x + self.dx * self.size[0]) * self.size[0],
                                                 (self.y + self.dy * self.size[0]) * self.size[1],
                                                 (self.z + self.dz * self.size[0]) * self.size[2]], axis=1)

        return transformation

    def __str__(self):
        return f"Tbl_row={self.row}, voxel_size={self.size}"


class EM:
    """
    Dynamo produces subtomogram averaging volume data in .em format and stores binary data.
    See EMDB_mapFormat MODE at http://ftp.ebi.ac.uk/pub/databases/emdb/doc/Map-format/current/EMDB_map_format.pdf,
    After unpacking, the first number indicates the type of data. It is then followed by 3 numbers, denoting the numbers of columns, rows and sections.
    The rest is volume data.
    """

    def __init__(self, filename):
        self.filename = filename

        with open(self.filename, 'rb') as em:
            # the header is 128 words = 512 bytes. np.dtype = "int32" (long integer)
            # we read the first 4 words (word = 4 bytes)
            self.dynamo_header = struct.unpack('128i', em.read(128 * 4))
            # determine the MODE
            self.dy_mode = int(hex(self.dynamo_header[0])[2])
            if self.dy_mode == 2:  # int16, short int
                self.mode = 1
                type_flag = "h"
            elif self.dy_mode == 4:  # int32, int
                self.mode = 3
                type_flag = "i"
            elif self.dy_mode == 5:  # float32
                self.mode = 2
                type_flag = "f"
            elif self.dy_mode == 9:  # float64
                self.mode = 4
                type_flag = "d"
            else:
                raise NotImplementedError("data not supported yet!")

            # pick the col, row, sect values
            self.nc, self.nr, self.ns = self.dynamo_header[1:4]
            # then we read the data
            self.raw_data = em.read()
            self.volume_data = struct.unpack(f'{self.nc * self.nr * self.ns}{type_flag}', self.raw_data)

    @property
    def volume_encoded(self):
        return base64.b64encode(self.raw_data)

    @property
    def volume_compressed(self):
        import zlib
        return zlib.compress(self.raw_data)

    @property
    def volume_encoded_compressed(self):
        return base64.b64encode(self.volume_compressed)

    @property
    def volume_array(self):
        import numpy
        # todo: float32 should vary, according to dy_mode?
        return numpy.array(self.volume_data, dtype=numpy.float32).reshape(self.nc, self.nr, self.ns)


def rearrange_matrix_tbl(args):
    # Map information
    map = Map(args.tomogram_file)
    map_origin = map.origin
    map_size = map.voxel_size.tolist()
    origin_m = np.array(
        [[0, 0, 0, map_origin[0] * map_size[0]], [0, 0, 0, map_origin[1] * map_size[1]],
         [0, 0, 0, map_origin[2] * map_size[2]]])

    # Tbl transformation
    tbl = Tbl(f"{args.dynamo_files[1]}")

    # .em data shape
    em = EM(f"{args.dynamo_files[0]}")
    box = em.volume_array.shape
    # Subtract half of the box_length
    half_box_m = np.array(
        [[0, 0, 0, (1 / 2) * box[0] * map_size[0]], [0, 0, 0, (1 / 2) * box[1] * map_size[1]],
         [0, 0, 0, (1 / 2) * box[2] * map_size[2]]])

    # A list contains the transformation of all particles
    transformations = []
    for i in range(tbl.rows):
        tbl_row = TblRow(tbl[i], map_size)
        tbl_m = tbl_row.transformation
        transform_m = (tbl_m + origin_m - half_box_m)
        transformations.append(transform_m.tolist())

    return tbl, transformations


def rearrange_matrix_motl(args):
    # todo: modify this script, especially args -> for .motl files.
    # todo: change the endings of .em into .motl -> prevent confusion
    # todo: check that map_t and map_s have the same voxel size
    #  and origins

    # Check that STA and tomogram have the same voxel-size
    map_t = Map(args.tomogram_file)
    map_s = Map(args.motl_files[0])
    t_size = map_t.voxel_size
    s_size = map_s.voxel_size
    # todo: commented out this raise ValueError
    #if t_size != s_size:
    #    raise ValueError("STA map does not have the same voxel-size as the tomogram")

    # Tomogram information
    map_origin = map_t.origin
    t_map_size = t_size.tolist()
    sta_map_size = s_size.tolist()
    # map_size = [0.445, 0.445, 0.445]
    origin_m = np.array(
        [[0, 0, 0, map_origin[0] * t_map_size[0]], [0, 0, 0, map_origin[1] * t_map_size[1]],
         [0, 0, 0, map_origin[2] * t_map_size[2]]])

    # map_s shape
    shape = (map_s.cols, map_s.rows, map_s.sections)
    #half_box_m = np.array([
    #    [0, 0, 0, 1 / 2 * shape[0] * t_map_size[0]],
    #    [0, 0, 0, 1 / 2 * shape[1] * t_map_size[1]],
    #    [0, 0, 0, 1 / 2 * shape[2] * t_map_size[2]]
    #])

    #half_box_m = np.array([
    #    [0, 0, 0, 1 / 2 * shape[0] * t_map_size[0]],
    #    [0, 0, 0, 1 / 2 * shape[1] * t_map_size[1]],
    #    [0, 0, 0, 1 / 2 * shape[2] * t_map_size[2]]
    #])

    # half_box_m = np.array([
    #    [0, 0, 0, 1 / 2 * shape[0]],
    #    [0, 0, 0, 1 / 2 * shape[1]],
    #    [0, 0, 0, 1 / 2 * shape[2]]
    # ])

    # motl transformation
    motl = Motl(f"{args.motl_files[1]}")

    # A list contains the transformation of all particles
    transformations = []
    for i in range(motl.rows):
        motl_row = MotlRow(motl[i], t_map_size)
        motl_m = motl_row.transformation
        # transform_m = (motl_m + origin_m   - half_box_m)
        transform_m = (motl_m + origin_m)
        transformations.append(transform_m.tolist())

    return motl, transformations


def create_output_tbl(args):
    # Output the text file
    tbl, transformations = rearrange_matrix_tbl(args)
    em = EM(f"{args.dynamo_files[0]}")
    map = Map(f"{args.tomogram_file}")
    with open("output.txt", "w") as f:
        for i in range(tbl.rows):
            line_to_write = str(i + 1) + "," \
                            + "".join(
                str(f"{e},").replace("[", "").replace("]", "").replace(" ", "") for e in transformations[i]) \
                            + "0,0,0,1\n"
            f.write(line_to_write)

        f.write("Mode:" + "\t" + str(em.mode) + "\n")
        f.write("Nc:" + "\t" + str(em.nc) + "\n")
        f.write("Nr:" + "\t" + str(em.nr) + "\n")
        f.write("Ns:" + "\t" + str(em.ns) + "\n")

        # uncompressed:0, compressed:1
        output_flag = 0
        if args.compress:
            f.write(f"Data:\t{em.volume_encoded_compressed.decode('utf-8')}")
            output_flag = 1
        else:
            f.write(f"Data:\t{em.volume_encoded.decode('utf-8')}")

    if not args.output:
        if output_flag == 1:
            os.rename("output.txt", r"output_c.txt")
            print("Data is compressed.")
            print("output_c.txt is created.")
        elif output_flag == 0:
            os.rename(rf"output.txt", r"output_nc.txt")
            print("Data is not compressed.")
            print("output_nc.txt is created.")
    elif args.output:
        os.rename(rf"output.txt", rf"{args.output}")
        if output_flag == 0:
            print("Data is not compressed.")
        elif output_flag == 1:
            print("Data is compressed.")
        print(f"{args.output}" + " is created.")

    if args.map_start:
        print("nxstart: " + str(map.origin[0]) + "\n" +
              "nystart: " + str(map.origin[1]) + "\n" +
              "nzstart: " + str(map.origin[2]))

    if args.voxel_size:
        print("voxel_size in x, y, z: " + str(map.voxel_size))


def create_output_motl(args):
    # Output the text file
    motl, transformations = rearrange_matrix_motl(args)
    # todo: have to edit here - encode the binary data from .map, eg emd_3465.map

    map_s = Map(f"{args.motl_files[0]}")
    map_t = Map(f"{args.tomogram_file}")
    with open("output.txt", "w") as f:
        for i in range(motl.rows):
            line_to_write = str(i + 1) + "," \
                            + "".join(
                str(f"{e},").replace("[", "").replace("]", "").replace(" ", "") for e in transformations[i]) \
                            + "0,0,0,1\n"
            f.write(line_to_write)

        f.write("Mode:" + "\t" + str(map_s.mode) + "\n")
        f.write("Nc:" + "\t" + str(map_s.cols) + "\n")
        f.write("Nr:" + "\t" + str(map_s.rows) + "\n")
        f.write("Ns:" + "\t" + str(map_s.sections) + "\n")

        # Encode the map_s data into strings - find the mode first (!= dynamo mode)
        if map_s.mode == 2:
            type_flag = "f"
        elif map_s.mode == 1:
            type_flag = "h"
        elif map_s.mode == 3:
            type_flag = "i"
        elif map_s.mode == 4:
            type_flag = "d"
        else:
            raise TypeError("The map mode is not supported yet!")

        # Then encode the values into string
        raw_data = map_s.data.flatten()
        packed_data = struct.pack(f"{len(raw_data)}{type_flag}", *raw_data)
        encoded_data = base64.b64encode(packed_data)

        # uncompressed:0, compressed:1
        output_flag = 0
        if args.compress:
            c_packed_data = zlib.compress(packed_data)
            c_encoded_data = base64.b64encode(c_packed_data)
            f.write(f"Data:\t{c_encoded_data.decode('utf-8')}")
            output_flag = 1
        else:
            f.write(f"Data:\t{encoded_data.decode('utf-8')}")

    if not args.output:
        if output_flag == 1:
            os.rename("output.txt", r"output_c.txt")
            print("Data is compressed.")
            print("output_c.txt is created.")
        elif output_flag == 0:
            os.rename(rf"output.txt", r"output_nc.txt")
            print("Data is not compressed.")
            print("output_nc.txt is created.")
    elif args.output:
        os.rename(rf"output.txt", rf"{args.output}")
        if output_flag == 0:
            print("Data is not compressed.")
        elif output_flag == 1:
            print("Data is compressed.")
        print(f"{args.output}" + " is created.")

    if args.map_start:
        print("nxstart: " + str(map_t.origin[0]) + "\n" +
              "nystart: " + str(map_t.origin[1]) + "\n" +
              "nzstart: " + str(map_t.origin[2]))

    if args.voxel_size:
        print("voxel_size in x, y, z: " + str(map_t.voxel_size))


def parse_args():
    # Argparse
    # fixme: edit the names
    parser = argparse.ArgumentParser(
        description="Output a single file that contains transformation data and voxel data. "
                    "Default voxel data uncompressed. Now supported data source: Dynamo and .motl from Brigg's lab.")
    # Input data from different sources
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-dynamo", "--dynamo_files", nargs=2, metavar=("dynamo .em", "dynamo .tbl"),
                       help="the Dynamo .em and .tbl file.")
    group.add_argument("-motl", "--motl_files", nargs=2, metavar=("Brigg's .csv file", "Brigg's motl produced STa map"),
                       help="the motl format files, include one STa map and one transformed .csv table from "
                            "Brigg's lab (the transformed .csv should be produced by the R script")

    # Optional arguments
    parser.add_argument("-o", "--output", help="the output file name (.txt)")
    parser.add_argument("-c", "--compress", default=False, action="store_true",
                        help="Compress the voxel data [default: False]")
    parser.add_argument("-t", "--tomogram-file", metavar="", required=True, help="The original .map file")
    parser.add_argument("-s", "--map-start", default=False, action="store_true",
                        help="Print the nxstart, nystart, nzstart of the original .map file")
    parser.add_argument("-v", "--voxel-size", default=False, action="store_true",
                        help="Print the voxel-size of the .map file")
    args = parser.parse_args()

    return args


def main():
    args = parse_args()

    if not os.path.exists(f"{args.tomogram_file}"):
        raise ValueError(f"{args.tomogram_file} does not exist")

    # todo: are there better ways?
    if "-dynamo" in sys.argv or "--dynamo_files" in sys.argv:
        for i in [0, 1]:
            if not os.path.exists(f"{args.dynamo_files[i]}"):
                raise ValueError(f"file {args.dynamo_files[i]} does not exist")

        create_output_tbl(args)
        print("Source file from Dynamo")

    elif "-motl" in sys.argv or "--motl_files" in sys.argv:
        for i in [0, 1]:
            if not os.path.exists(f"{args.motl_files[i]}"):
                raise ValueError(f"file {args.motl_files[i]} does not exist")

        create_output_motl(args)
        print("Source file from Brigg's lab")

    return 0


# only run main if this script is being executed
if __name__ == "__main__":
    sys.exit(main())
